<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>DOrder by rowangithub</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">DOrder</h1>
      <h2 class="project-tagline">DOrder -- Automatically Learning Shape Specifications</h2>
      <a href="https://github.com/rowangithub/DOrder" class="btn">View on GitHub</a>
      <a href="https://github.com/rowangithub/DOrder/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/rowangithub/DOrder/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="dorder" class="anchor" href="#dorder" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DOrder</h1>

<p><a href="https://www.cs.purdue.edu/homes/zhu103/pubs/draft.pdf">
    Link to the paper on Automatically Learning Shape Specifications.</a></p>

<p><a href="https://www.dropbox.com/s/hrk7nyqbifa25on/PLDI.ova?dl=0">
    Link to the virtual machine of DOrder.</a>  </p>

<p>To play with the virtual machine, please read the section
<a href="#AEC">"PLDI'16 AEC: Run the benchmarks from the paper"</a>.</p>

<h3>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h3>
    

<p>DOrder is copyrighted by Purdue University.</p>

<p>Author: He Zhu, Gustavo Petri, Suresh Jagannathan.  </p>

<p><strong>DOrder</strong> is a specification synthesizer written in OCaml that
runs on top of the OCaml compiler. It is capable of synthesizing shape 
specifications for OCaml data structure programs with <strong>no</strong> user-annotations. 
It only requires a <strong>small</strong> number of <strong>simple tests</strong>
to bootstrap synthesis. </p>

<p>Below, we provide a guide for fun things you can play with DOrder, with
pointers to the <a href="https://www.cs.purdue.edu/homes/zhu103/pubs/draft.pdf">paper</a> 
for further information.</p>

<p>You can also git-clone the source code of DOrder:</p>

<pre><code>    git clone https://github.com/rowangithub/DOrder.git
</code></pre>

<p>System requirements:</p>

<ol>
<li>
<p>OCaml 3.12:</p>

<p>The tool is currently incompatible with OCaml 4.0+. We hope to improve our code in the future.
The following instructions assume OCaml library is installed under /usr/local/lib/ocaml/, which is
also the default setting. If not, please make necessary changes according to your machine.</p>
</li>
<li>
<p>Z3 4.3:</p>

<p>DOrder requires Z3 to be installed. Download and install Z3 following all instructions provided 
<a href="https://github.com/Z3Prover/z3">here</a>. 
We strongly recommend Z3 4.3. To bind Z3 to DOrder, we require users to manually </p>

<pre><code>    Go into external/z3/ocaml, and run ./build-lib.sh /usr/local/lib/ocaml/
</code></pre>

<p>Please also put libz3.dylib or libz3.so (these files are available upon success compilation of Z3) 
under external/z3/lib.
If any problem is encountered, please follow the ReadMe provided under external/z3/ocaml.</p>
</li>
<li>
<p>CamlIDL: </p>

<p>CamlIDL can be downloaded from <a href="http://caml.inria.fr/pub/old_caml_site/camlidl/">here</a>.</p>
</li>
</ol>

<p>To detect whether an operating system supports DOrder, </p>

<pre><code>        Run ./configure
</code></pre>

<p>To compile DOrder, from the top directory:</p>

<pre><code>        Run make libs &amp;&amp; make   
</code></pre>

<p>To run DOrder, </p>

<ol>
<li>
<p>In MacOS, be sure that the files in external/Z3/lib are in your library path (not required in Ubuntu).<br>
One way to do this is to run, from the top directory,</p>

<pre><code>    export DYLD_LIBRARY_PATH="external/z3/lib/:$DYLD_LIBRARY_PATH"
</code></pre>
</li>
<li>
<p>To test whether DOrder is successfully complied, run</p>

<pre><code>    ./msolve.py ./tests/recursive/mcCarthy91.ml
</code></pre>
</li>
</ol>

<p>A precise specification for the well-known mcCarthy91 function should be
displayed. For any other problem with compiling DOrder, 
send an email to zhu103 AT myuniversity.</p>

<h1>
<a id="pldi16-aec-run-the-benchmarks-from-the-paper" class="anchor" href="#pldi16-aec-run-the-benchmarks-from-the-paper" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="AEC">PLDI'16 AEC: Run the benchmarks from the paper</a>
</h1>

<p>This section gives an example about how to validate DOrder. </p>

<h3>
<a id="benchmark-location" class="anchor" href="#benchmark-location" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Benchmark location:</h3>
        

<pre><code>    ./tests/reachability/
</code></pre>

<p>To run a benchmark [bench]:</p>

<pre><code>    ./msolve.py -no_hoflag -reachability ./tests/reachability/[bench]
</code></pre>

<h3>
<a id="more-explanation-about-benchmarks" class="anchor" href="#more-explanation-about-benchmarks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>More explanation about benchmarks:</h3>

<ol>
<li>
<p>The inductive data structure program benchmarks, for Automatically Learning Shape Specifications, are included in ./tests/reachability/ directory.
We can infer and verify specifications involving rich ordering properties of data structures 
(e.g. in AVL insertion function, the in-order relation of the output binary tree preserves the in-order relations of the input binary tree;
in list reversal function, the forward-order relation of the output list is equivalent to the backward-order relation of the input list;
in heap merge function, the parent-child relation of the output heap preserves the parent-child relations of the input heaps). 
We support arbitrary user-defined algebra data types. Examples include AVL tree, Splay tree, Braun tree, Skew heap, Treap, etc.</p>

<pre><code>To try an example, run ./msolve.py -no_hoflag -reachability ./tests/reachability/binarysearchtree.ml
</code></pre>
</li>
<li>
<p>You should be able to observe specifications inferred for each function in <em>binarysearchtree</em> from your command line interface, 
which will be explained below. If you prefer to observe the output in a file, add "-dump_specs" parameter, you can then read the 
synthesized specifications in a file "./specifications.txt".</p>

<pre><code>e.g. ./msolve.py -no_hoflag -reachability -dump_specs ./tests/reachability/binarysearchtree.ml
</code></pre>
</li>
<li><p>We also support the inference and verification of shape-data specifications. For example, we can infer and verify functional
correctness specifications for classic list sorting algorithms (e.g. quicksort, mergesort and heapsort) or 
balanced tree data structure programs (e.g. AVL and Redblack),
proving lists are correctly sorted or trees correctly satisfy BST properties.
Running our tool using the above commands will also display all the synthesized shape-data specifications.</p></li>
</ol>

<h3>
<a id="assumptions-made-by-dorder" class="anchor" href="#assumptions-made-by-dorder" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Assumptions made by DOrder:</h3>

<p>For any data structure program <em>prog</em>,
DOrder assumes test inputs to <em>prog</em> are provided in a file <em>prog_harness</em>.
These test inputs can be generated from automated tools like <em>quickcheck</em>.
In fact, all test inputs from <em>harness</em> files are in <em>quickcheck</em> style.
They are all very <em>simple</em>.
If used to synthesize specifications for some new data structure, 
make sure a new <em>harness</em> file for the data structure is created.
Many existing <em>harness</em> test files in the repository are reusable. </p>

<p>For example, consider the <em>heapsort</em> program under ./test/reachability.
Its test inputs are described in <em>heapsort_harness</em>, 
which contains the following code:</p>

<pre><code>let list n = random _n_ integers

let main () = 
    let _ = fprintf outch "env:newtest\t\n" in
    heapsort (list 15)
let _ = main ()
</code></pre>

<p>The line "let _ = fprintf outch "env:newtest\t\n" in" is used to tell
DOrder to collect input-output behaviors of the function below it 
(e.g. <em>heapsort</em>). The function is then called with a randomly generated
list whose length equals 15. </p>

<h3>
<a id="output-explanation" class="anchor" href="#output-explanation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Output explanation:</h3>

<p>If "-dump_specs" is used as a parameter to call DOrder, you can
read synthesized specifications in "./specifications.txt". Otherwise,
you can directly read synthesized result from the command line interface.</p>

<p>Synthesized specifications are boolean combinations of a set of atomic 
predicates inferred <em>per-datatype</em>. For example, consider the data type 
<em>heap</em> provided in the <em>heapsort</em> program.</p>

<pre><code>type 'a heap = 
    | E 
    | T of int * 'a * 'a heap * 'a heap
</code></pre>

<p>A number of atomic predicates are created from this data type,
which essentially is a tree data structure.
We will use <em>h</em> to represent an instance of 'a heap.
Following Section.2 of the paper,
we first consider possible containment predicates for <em>h</em>:</p>

<pre><code>    reach (h, u) represents a certain value u is present in a heap h:
</code></pre>

<p>A more interesting predicate class is one that establishes
ordering relations between two elements of a data structure,
u and v. Recall that in the heap definition only <em>T</em> constructors
contain values. However, since <em>T</em> contains two
inductively defined subtrees, there are several cases to consider
when establishing an ordering relation among values
found within a tree <em>h</em>. We use <strong>link (h, t, i, j, u, v)</strong> 
to represent the ordering relation that u is contained the <strong>i-th</strong> component and 
v is in the <strong>j-th</strong> component of constructor <em>T</em> in <em>h</em> (<em>T</em> is uncapitalized
in the predicate).
For example, if we are interested in cases where the
value u appears “before” (according to a specified order) v,
we could either have that: </p>

<pre><code>    (i) the value v occurs in the first (left) subtree (indexed by 2) from a tree 
    node containing u (indexed by 1), described by the notation link (h, t, 1, 2, u, v), 

    (ii) the value v occurs in the second (right) subtree (indexed by 3), described by the 
    notation link (h, t, 1, 3, u, v),

    (iii) both values are in the tree, but u is found in a subtree that is disjoint from the subtree 
    where v occurs. Suppose there exists a node whose first subtree contains u (indexed by 2) and whose 
    second subtree contains v (indexed by 3). This is denoted as link (h, t, 2, 3, u, v). 
</code></pre>

<p>Notice that in this description we have exhausted all possible relations between any two
values in a tree.<br>
The first argument (indexed by 0) to the <em>T</em> constructor is not considered by all atomic predicates 
because integer is not part of the polymorphic data structure 'a heap (type theory).</p>

<p><strong><a name="simplification">Simplification:</a></strong> Given a predicate link (h, t, i, j, u, v), 
to improve <em>readability</em> of DOrder, for a polymorphic data structure <em>'a</em> <em>type</em>,
if the i-th component of constructor <em>T</em> is the only polymorphic argument of <em>T</em> 
that is not an inductive data type (e.g. simple list or tree data structure), 
we simplify the output of the predicate to link (h, t, j, u, v) because 
i is obvious and hence hidden in this case. </p>

<p>After synthesizing atomic predicates from datatype definition, 
DOrder synthesizes specifications for data structure functions. 
Consider the <em>merge</em> function in <em>heapsort</em>,</p>

<pre><code>let rec merge h1 h2 =
    match h1, h2 with 
    | h1, E -&gt; h1 
    | E, h2 -&gt; h2 
    | (T(rk1, x, a1, b1)), (T(rk2, y, a2, b2)) -&gt; 
        if x &gt;= y then 
            t x a1 (merge b1 h2) 
        else 
            t y a2 (merge h1 b2)
</code></pre>

<p>By learning from test outcome, the following specification is synthesized:</p>

<pre><code>function merge with type h1: {'a heap | some type omitted ... } 
    -&gt; h2: {'a heap | sometype omitted ... }
    -&gt; {'a heap |                                       
            forall (u v ). ((not link (V, t, 1, 2, u, v)) or 
            link (h2, t, 1, 2, u, v) or
            link (h2, t, 1, 3, u, v) or
            (link (h1, t, 1, 3, u, v) or 
            link (h1, t, 1, 2, u, v)) or
            ((reach (h2, u)) and (reach (h1, v))) or
            ((reach (h2, v)) and (reach (h1, u)))) /\ ...}
</code></pre>

<p>We only show one predicate in the result of the function for simplicity.
In the result type, V represents the value of the result heap. The given specification 
states that the parent-child relation (e.g. link (V, t, 1, 2, u, v) where u and v are free) 
between elements contained in the result heap preserves their parent-child relation 
(e.g. link (h2, t, 1, 2, u, v)) in the input heap h1 and h2. [You might find that
link (V, t, 1, 2, u, v) is simplified to link (V, t, 2, u, v) in the output due to the 
<a href="#simplification">simplification strategy</a>.]</p>

<p>DOrder also outputs <em>shape-data</em> specifications. For example, for the <em>heapsort</em> function,
the following specification is synthesized:</p>

<pre><code>function heapsort with type ls: 'a list -&gt;
    {'a list | forall (u v ). ((not link (V, cons, 0, 1, u, v)) or  (v &lt;= u)) /\ ...}
</code></pre>

<p>In the result type, we see that the output list is correctly sorted, where <em>cons</em>
is the uncapitalized version the Cons data type constructor of list.</p>

<h3>
<a id="how-to-validate-dorder" class="anchor" href="#how-to-validate-dorder" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How to validate DOrder:</h3>

<p>To validate our experimental results, we displayed detailed runtime information in the
command line interface. For example, assume you run DOrder with</p>

<pre><code>&gt;&gt;&gt; ./msolve.py -no_hoflag -reachability -dump_specs ./tests/reachability/heapsort.ml

##time##

Time to solve constraints:
TOTAL                         29.109 s
    learn_from_samples             9.160 s

##Size of hypothesis domain: 81##
##In total 28 specifications were synthesized in the above command lines. QED.
</code></pre>

<p>Here the number of atomic predicates in the hypothesis domain of all the functions in <em>heapsort</em>
is 81 (column H of Tab.5), the number of verified ordering specifications in terms of either input-output or shape-data relations
is 28 (column I of Tab.5). The total time taken (learning and verification) is 40.653s (column T of Tab.5). 
The time spent solely on learning (including the time spent in sampling) is 9.160s (column LT of Tab.5).
Please do not take the time so serious because it depends on the machine we use.
Inferred specifications can be found either in command lines or "./specifications.txt" depending on
whether "-dump_specs" is used in the parameter to call DOrder.  </p>

<p>Readers are welcome to validate the experimental results listed in Tab.5 of the paper,
following these steps.</p>

<h3>
<a id="more-examples" class="anchor" href="#more-examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>More examples:</h3> 
 

<p><a href="https://www.cs.purdue.edu/homes/zhu103/pubs/example.pdf">
    More examples on DOrder output (example syntax follows the paper and
    is directly consistent with link and reach predicates given above).</a> </p>

<h1>
<a id="learning-other-specifications-beyond-the-paper" class="anchor" href="#learning-other-specifications-beyond-the-paper" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Learning other specifications beyond the paper</h1>

<ol>
<li>
<p>In addition to the above ordering properties, DOrder can also infer and verify inductive numeric specifications for data structures. For example,
we can infer and verify functional correctness specifications for balanced tree structures (e.g. AVL and Redblack), proving trees can be correctly balanced in
the data structure implementations. The corresponding inductive data structure benchmarks are included in ./tests/dml/ directory. </p>

<pre><code>To try an example, run ./msolve.py -no_hoflag ./tests/dml/bdd.ml or

                       ./moslve.py -no_hoflag ./tests/dml/set.ml
</code></pre>
</li>
<li>
<p>DOrder not only handles data structure programs, but also can be used to infer specifications for numeric programs.
The <em>loop</em> (numeric) program benchmarks are included in ./tests/folprograms/ directory.</p>

<pre><code>To try an example, run ./msolve.py -no_hoflag ./tests/folprograms/misc/popl07.ml
</code></pre>

<p>The <em>recursive</em> (numeric) program benchmarks are included in ./tests/recursive/ directory. </p>

<pre><code>To try an example, run ./msolve.py -no_hoflag ./tests/recursive/fibonacci01.ml
</code></pre>
</li>
<li>
<p>DOrder supports <em>high-order</em> functions. The higher-order (numeric) program benchmarks are included 
in ./tests/mochi/ ./tests/lists/ and ./tests/popl13/ directories.</p>

<pre><code>To try an example, run ./msolve.py -hoflag ./tests/mochi/ainit.ml
</code></pre>
</li>
<li>
<p>DOrder can synthesize quantified array invariants.
The <em>array</em> program benchmarks are included in ./tests/array/</p>

<pre><code>To try an example, run ./msolve.py -inv -effect ./tests/array/a_quicksort_partition.ml
</code></pre>
</li>
</ol>

<h1>
<a id="summary-dorder-command-line-arguments" class="anchor" href="#summary-dorder-command-line-arguments" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Summary: DOrder Command Line Arguments</h1>

<ol>
<li>
<p>To infer shape 
        specifications on top of ordering and containment properties for data structure programs, run</p>

<pre><code>./msolve.py -no_hoflag -reachability [ML source file]
</code></pre>
</li>
<li>
<p>To infer specifications for general high-order functional programs, run</p>

<pre><code>./msolve.py -hoflag [ML source file]
</code></pre>
</li>
<li>
<p>To turn off the support for higher-order functions (for first-order programs), run</p>

<pre><code>./msolve.py -no_hoflag [ML source file]
</code></pre>
</li>
<li>
<p>To infer quantified array invariants, run</p>

<pre><code>./moslve.py -inv -effect [ML source file]
</code></pre>
</li>
</ol>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/rowangithub/DOrder">DOrder</a> is maintained by <a href="https://github.com/rowangithub">rowangithub</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
