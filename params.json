{"name":"DOrder","tagline":"DOrder -- Automatically Learning Shape Specifications","body":"DOrder\r\n==================\r\n\r\n<a href=\"https://www.cs.purdue.edu/homes/zhu103/pubs/draft.pdf\">\r\n\tLink to the paper on Automatically Learning Shape Specifications.</a>\r\n\t\r\n<a href=\"https://www.dropbox.com/s/hrk7nyqbifa25on/PLDI.ova?dl=0\">\r\n\tLink to the virtual machine of DOrder.</a>\t\r\n\r\nTo play with the virtual machine, please read the section\r\n<a href=\"#AEC\">\"PLDI'16 AEC: Run the benchmarks from the paper\"</a>.\r\n\t\r\n<h3>Overview</h3>\r\n\t\r\nDOrder is copyrighted by Purdue University.\r\n\r\nAuthor: He Zhu, Gustavo Petri, Suresh Jagannathan.\t\r\n\t\r\n<strong>DOrder</strong> is a specification synthesizer written in OCaml that\r\nruns on top of the OCaml compiler. It is capable of synthesizing shape \r\nspecifications for OCaml data structure programs with <strong>no</strong> user-annotations. \r\nIt only requires a <strong>small</strong> number of <strong>simple tests</strong>\r\nto bootstrap synthesis. \r\n\r\nBelow, we provide a guide for fun things you can play with DOrder, with\r\npointers to the <a href=\"https://www.cs.purdue.edu/homes/zhu103/pubs/draft.pdf\">paper</a> \r\nfor further information.\r\n\r\nYou can also git-clone the source code of DOrder:\r\n\r\n\t\tgit clone https://github.com/rowangithub/DOrder.git\r\n\t\r\nSystem requirements:\r\n\r\n1. OCaml 3.12:\r\n\r\n\tThe tool is currently incompatible with OCaml 4.0+. We hope to improve our code in the future.\r\n\tThe following instructions assume OCaml library is installed under /usr/local/lib/ocaml/, which is\r\n\talso the default setting. If not, please make necessary changes according to your machine.\r\n\t\r\n2. Z3 4.3:\r\n\r\n\tDOrder requires Z3 to be installed. Download and install Z3 following all instructions provided \r\n\t<a href=\"https://github.com/Z3Prover/z3\">here</a>. \r\n\tWe strongly recommend Z3 4.3. To bind Z3 to DOrder, we require users to manually \r\n\r\n\t\t\tGo into external/z3/ocaml, and run ./build-lib.sh /usr/local/lib/ocaml/\r\n\r\n\tPlease also put libz3.dylib or libz3.so (these files are available upon success compilation of Z3) \r\n\tunder external/z3/lib.\r\n\tIf any problem is encountered, please follow the ReadMe provided under external/z3/ocaml.\r\n\t\r\n3. CamlIDL:\t\r\n\r\n\tCamlIDL can be downloaded from <a href=\"http://caml.inria.fr/pub/old_caml_site/camlidl/\">here</a>.\r\n\t\r\n\t\r\nTo detect whether an operating system supports DOrder, \r\n\r\n\t\t\tRun ./configure\r\n\r\nTo compile DOrder, from the top directory:\r\n\r\n\t        Run make libs && make\t\r\n\t\r\nTo run DOrder, \r\n\r\n1. In MacOS, be sure that the files in external/Z3/lib are in your library path (not required in Ubuntu).  \r\nOne way to do this is to run, from the top directory,\r\n\t\r\n\t\t\texport DYLD_LIBRARY_PATH=\"external/z3/lib/:$DYLD_LIBRARY_PATH\"\r\n\r\n2. To test whether DOrder is successfully complied, run\r\n\r\n\t\t\t./msolve.py ./tests/recursive/mcCarthy91.ml\r\n\t\r\nA precise specification for the well-known mcCarthy91 function should be\r\ndisplayed. For any other problem with compiling DOrder, \r\nsend an email to zhu103 AT myuniversity.\r\n\r\n\r\n\r\n<a name=\"AEC\">PLDI'16 AEC: Run the benchmarks from the paper</a>\r\n===========\r\n\r\nThis section gives an example about how to validate DOrder. \r\n\r\n<h3>Benchmark location:</h3>\r\n\t\t\r\n\t\t./tests/reachability/\r\n\r\n<h3>How to run DOrder:</h3>\r\n\r\n1. The inductive data structure program benchmarks, for Automatically Learning Shape Specifications, are included in ./tests/reachability/ directory.\r\nWe can infer and verify specifications involving rich ordering properties of data structures \r\n(e.g. in AVL insertion function, the in-order relation of the output binary tree preserves the in-order relations of the input binary tree;\r\nin list reversal function, the forward-order relation of the output list is equivalent to the backward-order relation of the input list;\r\nin heap merge function, the parent-child relation of the output heap preserves the parent-child relations of the input heaps). \r\nWe support arbitrary user-defined algebra data types. Examples include AVL tree, Splay tree, Braun tree, Skew heap, Treap, etc.\r\n\r\n\t\tTo try an example, run ./msolve.py -no_hoflag -reachability ./tests/reachability/binarysearchtree.ml\r\n\t\t\r\n2. You should be able to observe specifications inferred for each function in _binarysearchtree_ from your command line interface, \r\nwhich will be explained below. If you prefer to observe the output in a file, add \"-dump_specs\" parameter, you can then read the \r\nsynthesized specifications in a file \"./specifications.txt\".\r\n\t\t\t\t\t\r\n\t\te.g. ./msolve.py -no_hoflag -reachability -dump_specs ./tests/reachability/binarysearchtree.ml\r\n\t\t\t\t\r\n\r\n3. We also support the inference and verification of shape-data specifications. For example, we can infer and verify functional\r\ncorrectness specifications for classic list sorting algorithms (e.g. quicksort, mergesort and heapsort) or \r\nbalanced tree data structure programs (e.g. AVL and Redblack),\r\nproving lists are correctly sorted or trees correctly satisfy BST properties.\r\nRunning our tool using the above commands will also display all the synthesized shape-data specifications.\r\n\r\n\r\n<h3>Assumptions made by DOrder:</h3>\r\n\r\nFor any data structure program _prog_,\r\nDOrder assumes test inputs to _prog_ are provided in a file <em>prog_harness</em>.\r\nThese test inputs can be generated from automated tools like _quickcheck_.\r\nIn fact, all test inputs from _harness_ files are in _quickcheck_ style.\r\nThey are all very _simple_.\r\nIf used to synthesize specifications for some new data structure, \r\nmake sure a new _harness_ file for the data structure is created.\r\nMany existing _harness_ test files in the repository are reusable. \r\n\r\nFor example, consider the _heapsort_ program under ./test/reachability.\r\nIts test inputs are described in <em>heapsort_harness</em>, \r\nwhich contains the following code:\r\n\r\n\tlet list n = random _n_ integers\r\n\r\n\tlet main () = \r\n\t\tlet _ = fprintf outch \"env:newtest\\t\\n\" in\r\n\t\theapsort (list 15)\r\n\tlet _ = main ()\r\n\r\nThe line \"let _ = fprintf outch \"env:newtest\\t\\n\" in\" is used to tell\r\nDOrder to collect input-output behaviors of the function below it \r\n(e.g. _heapsort_). The function is then called with a randomly generated\r\nlist whose length equals 15. \r\n\r\n<h3>Output explanation:</h3>\r\n\r\nIf \"-dump_specs\" is used as a parameter to call DOrder, you can\r\nread synthesized specifications in \"./specifications.txt\". Otherwise,\r\nyou can directly read synthesized result from the command line interface.\r\n\r\nSynthesized specifications are boolean combinations of a set of atomic \r\npredicates inferred _per-datatype_. For example, consider the data type \r\n_heap_ provided in the _heapsort_ program.\r\n\r\n\ttype 'a heap = \r\n\t\t| E \r\n\t\t| T of int * 'a * 'a heap * 'a heap\r\n\t\t\r\nA number of atomic predicates are created from this data type,\r\nwhich essentially is a tree data structure.\r\nWe will use _h_ to represent an instance of 'a heap.\r\nFollowing Section.2 of the paper,\r\nwe first consider possible containment predicates for _h_:\r\n\r\n\t\treach (h, u) represents a certain value u is present in a heap h:\r\n\t\t\r\nA more interesting predicate class is one that establishes\r\nordering relations between two elements of a data structure,\r\nu and v. Recall that in the heap definition only _T_ constructors\r\ncontain values. However, since _T_ contains two\r\ninductively defined subtrees, there are several cases to consider\r\nwhen establishing an ordering relation among values\r\nfound within a tree _h_. We use <strong>link (h, t, i, j, u, v)</strong> \r\nto represent the ordering relation that u is contained the <strong>i-th</strong> component and \r\nv is in the <strong>j-th</strong> component of constructor _T_ in _h_ (_T_ is uncapitalized\r\nin the predicate).\r\nFor example, if we are interested in cases where the\r\nvalue u appears “before” (according to a specified order) v,\r\nwe could either have that: \r\n\r\n\t\t(i) the value v occurs in the first (left) subtree (indexed by 2) from a tree \r\n\t\tnode containing u (indexed by 1), described by the notation link (h, t, 1, 2, u, v), \r\n\r\n\t\t(ii) the value v occurs in the second (right) subtree (indexed by 3), described by the \r\n\t\tnotation link (h, t, 1, 3, u, v),\r\n\r\n\t\t(iii) both values are in the tree, but u is found in a subtree that is disjoint from the subtree \r\n\t\twhere v occurs. Suppose there exists a node whose first subtree contains u (indexed by 2) and whose \r\n\t\tsecond subtree contains v (indexed by 3). This is denoted as link (h, t, 2, 3, u, v). \r\n\r\nNotice that in this description we have exhausted all possible relations between any two\r\nvalues in a tree.\t\t\r\nThe first argument (indexed by 0) to the _T_ constructor is not considered by all atomic predicates \r\nbecause integer is not part of the polymorphic data structure 'a heap (type theory).\r\n\r\n\r\n<strong><a name=\"simplification\">Simplification:</a></strong> Given a predicate link (h, t, i, j, u, v), \r\nto improve _readability_ of DOrder, for a polymorphic data structure _'a_ _type_,\r\nif the i-th component of constructor _T_ is the only polymorphic argument of _T_ \r\nthat is not an inductive data type (e.g. simple list or tree data structure), \r\nwe simplify the output of the predicate to link (h, t, j, u, v) because \r\ni is obvious and hence hidden in this case. \r\n\r\nAfter synthesizing atomic predicates from datatype definition, \r\nDOrder synthesizes specifications for data structure functions. \r\nConsider the _merge_ function in _heapsort_,\r\n\r\n\tlet rec merge h1 h2 =\r\n\t\tmatch h1, h2 with \r\n\t\t| h1, E -> h1 \r\n\t\t| E, h2 -> h2 \r\n\t\t| (T(rk1, x, a1, b1)), (T(rk2, y, a2, b2)) -> \r\n\t\t\tif x >= y then \r\n\t\t\t\tt x a1 (merge b1 h2) \r\n\t\t\telse \r\n\t\t\t\tt y a2 (merge h1 b2)\r\n\t\r\nBy learning from test outcome, the following specification is synthesized:\r\n\t\r\n\tfunction merge with type h1: {'a heap | some type omitted ... } \r\n\t\t-> h2: {'a heap | sometype omitted ... }\r\n\t\t-> {'a heap |                              \t\t\t\r\n\t\t\t\tforall (u v ). ((not link (V, t, 1, 2, u, v)) or \r\n\t\t\t\tlink (h2, t, 1, 2, u, v) or\r\n\t\t\t\tlink (h2, t, 1, 3, u, v) or\r\n\t\t\t\t(link (h1, t, 1, 3, u, v) or \r\n\t\t\t\tlink (h1, t, 1, 2, u, v)) or\r\n\t\t\t\t((reach (h2, u)) and (reach (h1, v))) or\r\n\t\t\t\t((reach (h2, v)) and (reach (h1, u)))) /\\ ...}\r\n\r\nWe only show one predicate in the result of the function for simplicity.\r\nIn the result type, V represents the value of the result heap. The given specification \r\nstates that the parent-child relation (e.g. link (V, t, 1, 2, u, v) where u and v are free) \r\nbetween elements contained in the result heap preserves their parent-child relation \r\n(e.g. link (h2, t, 1, 2, u, v)) in the input heap h1 and h2. [You might find that\r\nlink (V, t, 1, 2, u, v) is simplified to link (V, t, 2, u, v) in the output due to the \r\n<a href=\"#simplification\">simplification</a>.]\r\n\r\nDOrder also outputs _shape-data_ specifications. For example, for the _heapsort_ function,\r\nthe following specification is synthesized:\r\n\r\n\tfunction heapsort with type ls: 'a list ->\r\n        {'a list | forall (u v ). ((not link (V, cons, 0, 1, u, v)) or  (v <= u)) /\\ ...}\r\n\r\nIn the result type, we see that the output list is correctly sorted, where _cons_\r\nis the uncapitalized version the Cons data type constructor of list.\r\n\r\n<h3>How to validate DOrder:</h3>\r\n\r\nTo validate our experimental results, we displayed detailed runtime information in the\r\ncommand line interface. For example, assume you run DOrder with\r\n\t\r\n\t>>> ./msolve.py -no_hoflag -reachability -dump_specs ./tests/reachability/heapsort.ml\r\n\t\r\n\t##time##\r\n\r\n\tTime to solve constraints:\r\n\tTOTAL                         29.109 s\r\n\t\tlearn_from_samples             9.160 s\r\n\t\t\r\n\t##Size of hypothesis domain: 81##\r\n\t##In total 28 specifications were synthesized in the above command lines. QED.\r\n\t\r\nHere the number of atomic predicates in the hypothesis domain of all the functions in _heapsort_\r\nis 81 (column H of Tab.5), the number of verified ordering specifications in terms of either input-output or shape-data relations\r\nis 28 (column I of Tab.5). The total time taken (learning and verification) is 40.653s (column T of Tab.5). \r\nThe time spent solely on learning (including the time spent in sampling) is 9.160s (column LT of Tab.5).\r\nPlease do not take the time so serious because it depends on the machine we use.\r\nInferred specifications can be found either in command lines or \"./specifications.txt\" depending on\r\nwhether \"-dump_specs\" is used in the parameter to call DOrder.\t\r\n\r\nReaders are welcome to validate the experimental results listed in Tab.5 of the paper,\r\nfollowing these steps.\r\n\r\n<h3>More examples:</h3> \r\n \r\n<a href=\"https://www.cs.purdue.edu/homes/zhu103/pubs/example.pdf\">\r\n\tMore examples on DOrder output (example syntax follows the paper and\r\n\tis directly consistent with link and reach predicates given above).</a> \r\n        \r\n\r\nLearning other specifications beyond the paper\r\n===========\r\n\r\n3. In addition to the above ordering properties, DOrder can also infer and verify inductive numeric specifications for data structures. For example,\r\nwe can infer and verify functional correctness specifications for balanced tree structures (e.g. AVL and Redblack), proving trees can be correctly balanced in\r\nthe data structure implementations. The corresponding inductive data structure benchmarks are included in ./tests/dml/ directory. \r\n\t\r\n\t\tTo try an example, run ./msolve.py -no_hoflag ./tests/dml/bdd.ml or\r\n\t\t \t\t\t\t\t   \r\n\t\t\t\t\t\t\t   ./moslve.py -no_hoflag ./tests/dml/set.ml\r\n\r\n4. DOrder not only handles data structure programs, but also can be used to infer specifications for numeric programs.\r\n\tThe _loop_ (numeric) program benchmarks are included in ./tests/folprograms/ directory.\r\n\r\n        To try an example, run ./msolve.py -no_hoflag ./tests/folprograms/misc/popl07.ml\r\n\r\n\tThe _recursive_ (numeric) program benchmarks are included in ./tests/recursive/ directory. \r\n\r\n\t\tTo try an example, run ./msolve.py -no_hoflag ./tests/recursive/fibonacci01.ml\r\n\r\n\r\n5. DOrder supports _high-order_ functions. The higher-order (numeric) program benchmarks are included \r\nin ./tests/mochi/ ./tests/lists/ and ./tests/popl13/ directories.\r\n\r\n\t\tTo try an example, run ./msolve.py -hoflag ./tests/mochi/ainit.ml\r\n\t\t\r\n6. DOrder can synthesize quantified array invariants.\r\n\tThe _array_ program benchmarks are included in ./tests/array/\r\n\t\r\n\t\tTo try an example, run ./msolve.py -inv -effect ./tests/array/a_quicksort_partition.ml\r\n\r\n\r\nSummary: DOrder Command Line Arguments\r\n==============\r\n\r\n1. To infer shape \r\n\t\t\tspecifications on top of ordering and containment properties for data structure programs, run\r\n\r\n\t\t./msolve.py -no_hoflag -reachability [ML source file]\r\n\r\n\r\n2. To infer specifications for general high-order functional programs, run\r\n       \r\n\t\t./msolve.py -hoflag [ML source file]\r\n\t\t\t\r\n\t\t\r\n3. To turn off the support for higher-order functions (for first-order programs), run\r\n\r\n\t\t./msolve.py -no_hoflag [ML source file]\r\n\t\t\r\n4. To infer quantified array invariants, run\r\n\r\n \t\t./moslve.py -inv -effect [ML source file]\r\n\t\t\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}