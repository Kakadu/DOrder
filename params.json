{"name":"Dorder","tagline":"DOrder -- Automatically Learning Shape Specifications","body":"DOrder\r\n==================\r\n\r\n<a href=\"https://www.cs.purdue.edu/homes/zhu103/pubs/draft.pdf\">\r\n\tLink to the paper on Automatically Learning Shape Specifications.</a>\r\n\t\r\nThis tool is copyrighted by Purdue University.\r\n\r\nAuthor: He Zhu, Gustavo Petri, Suresh Jagannathan.\t\r\n\t\r\n<strong>DOrder</strong> is a specification synthesizer written in OCaml that\r\nruns on top of the OCaml compiler. It is capable of synthesizing shape \r\nspecifications for OCaml data structure programs with <strong>no</strong> user-annotations. \r\nIt only requires a <strong>small</strong> number of <strong>simple tests</strong>\r\nto bootstrap synthesis. \r\n\r\nBelow, we provide a guide for fun things you can play with DOrder, with\r\npointers to the paper for further information.\r\n\r\n<h3>DOrder Virtual Machine</h3>\r\n\r\nBefore directly accessing DOrder's source code, we recommend a <a href=\"https://www.dropbox.com/s/hrk7nyqbifa25on/PLDI.ova?dl=0\">VM version</a> of DOrder.\r\nDOrder is complied and ready to be played in the VM version.\r\n\r\n<h3>DOrder Source Code</h3>\r\n\r\nYou can git-clone the source code of DOrder:\r\n\r\n\t\tgit clone https://github.com/rowangithub/DOrder.git\r\n\t\r\nSystem requirements:\r\n\r\n1. OCaml 3.12:\r\n\r\n\tThe tool is currently incompatible with OCaml 4.0+. We hope to improve our code in the future.\r\n\tThe following instructions assume OCaml library is installed under /usr/local/lib/ocaml/, which is\r\n\talso the default setting. If not, please make necessary changes according to your machine.\r\n\t\r\n2. Z3 4.3:\r\n\r\n\tDOrder requires Z3 to be installed. Download and install Z3 following all instructions provided \r\n\t<a href=\"https://github.com/Z3Prover/z3\">here</a>. \r\n\tWe strongly recommend Z3 4.3. To bind Z3 to DOrder, we require users to manually \r\n\r\n\t\t\tGo into external/z3/ocaml, and run ./build-lib.sh /usr/local/lib/ocaml/\r\n\r\n\tPlease also put libz3.dylib or libz3.so (these files are available upon success compilation of Z3) \r\n\tunder external/z3/lib.\r\n\tIf any problem is encountered, please follow the ReadMe provided under external/z3/ocaml.\r\n\t\r\n3. CamlIDL:\t\r\n\r\n\tCamlIDL can be downloaded from <a href=\"http://caml.inria.fr/pub/old_caml_site/camlidl/\">here</a>.\r\n\t\r\n\t\r\nTo detect whether an operating system supports DOrder, \r\n\r\n\t\t\tRun ./configure\r\n\r\nTo compile DOrder, from the top directory:\r\n\r\n\t        Run make libs && make\t\r\n\t\r\nTo run DOrder, \r\n\r\n1. In MacOS, be sure that the files in external/Z3/lib are in your library path (not required in Ubuntu).  \r\nOne way to do this is to run, from the top directory,\r\n\t\r\n\t\t\texport DYLD_LIBRARY_PATH=\"external/z3/lib/:$DYLD_LIBRARY_PATH\"\r\n\r\n2. To test whether DOrder is successfully complied, run\r\n\r\n\t\t\t./msolve.py ./tests/recursive/mcCarthy91.ml\r\n\t\r\nA precise specification for the well-known mcCarthy91 function should be\r\ndisplayed. For any other problem with compiling DOrder, \r\nsend an email to zhu103 AT myuniversity.\r\n\r\n\r\nOverview\r\n===========\r\n\r\nAbstractly, DOrder implements a general framework that \r\nautomatically synthesizes useful specifications as _refinement types_\r\nfor (higher-order) functional programs from test outcome.\r\n\r\nConcretely, DOrder presents a novel automated procedure for discovering\r\nexpressive shape specifications for sophisticated functional\r\ndata structures. Our approach extracts potential shape\r\npredicates based on the definition of constructors of arbitrary\r\nuser-defined inductive data types, and combines these\r\npredicates within an expressive first-order specification language\r\nusing a lightweight data-driven <strong>learning</strong> procedure.\r\n\r\nNotably, this technique requires no programmer annotations,\r\nand is equipped with a type-based decision procedure to verify\r\nthe correctness of discovered specifications. Experimental\r\nresults indicate that our implementation is both efficient\r\nand effective, capable of automatically synthesizing sophisticated\r\nshape specifications over a range of complex data\r\ntypes, going well beyond the scope of existing solutions.\r\n\r\n\r\nRun the benchmarks from the paper\r\n===========\r\n\r\n<h3>Benchmark location:</h3>\r\n\t\t\r\n\t\t./tests/reachability/\r\n\r\n<h3>How to:</h3>\r\n\r\n1. The inductive data structure program benchmarks, for Automatically Learning Shape Specifications, are included in ./tests/reachability/ directory.\r\nWe can infer and verify specifications involving rich ordering properties of data structures \r\n(e.g. in AVL insertion function, the in-order relation of the output binary tree preserves the in-order relations of the input binary tree;\r\nin list reversal function, the forward-order relation of the output list is equivalent to the backward-order relation of the input list;\r\nin heap merge function, the parent-child relation of the output heap preserves the parent-child relations of the input heaps). \r\nWe support arbitrary user-defined algebra data types. Examples include AVL tree, Splay tree, Braun tree, Skew heap, Treap, etc.\r\n\r\n\t\tTo try an example, run ./msolve.py -no_hoflag -reachability ./tests/reachability/binarytree.ml or\r\n\t\t\r\n\t\t\t\t\t\t\t   ./msolve.py -no_hoflag -reachability ./tests/reachability/avl2.ml or\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t \t   ./msolve.py -no_hoflag -reachability ./tests/reachability/redblackset.ml\r\n\r\n2. We also support the inference and verification of shape-data specifications. For example, we can infer and verify functional\r\ncorrectness specifications for classic list sorting algorithms (e.g. quicksort, mergesort and heapsort) or \r\nbalanced tree data structure programs (e.g. AVL and Redblack),\r\nproving lists are correctly sorted or trees correctly satisfy BST properties.\r\nRunning our tool using the above commands will also display all the synthesized shape-data specifications.\r\n\r\n\r\n<h3>Assumptions made by DOrder:</h3>\r\n\r\nFor any data structure program _prog_,\r\nDOrder assumes test inputs to _prog_ are provided in a file <em>prog_harness</em>.\r\nThese test inputs can be generated from automated tools like _quickcheck_.\r\nIn fact, all test inputs from _harness_ files are in _quickcheck_ style.\r\nThey are all very _simple_.\r\nIf used to synthesize specifications for some new data structure, \r\nmake sure a new _harness_ file for the data structure is created.\r\nMany existing _harness_ test files in the repository are reusable. \r\n\r\nFor example, consider the _heapsort_ program under ./test/reachability.\r\nIts test inputs are described in <em>heapsort_harness</em>, \r\nwhich contains the following code:\r\n\r\n\tlet list n = random _n_ integers\r\n\r\n\tlet main () = \r\n\t\tlet _ = fprintf outch \"env:newtest\\t\\n\" in\r\n\t\theapsort (list 15)\r\n\tlet _ = main ()\r\n\r\nThe line \"let _ = fprintf outch \"env:newtest\\t\\n\" in\" is used to tell\r\nDOrder to collect input-output behaviors of the function below it \r\n(e.g. _heapsort_).\r\n\r\n<h3>DOrder output explanation:</h3> \r\n\r\nSynthesized specifications are boolean combinations of a set of atomic \r\npredicates inferred _per-datatype_. For example, consider the data type \r\n_heap_ provided in the _heapsort_ program.\r\n\r\n\ttype 'a heap = \r\n\t\t| E \r\n\t\t| T of int * 'a * 'a heap * 'a heap\r\n\t\t\r\nA number of atomic predicates are created from this data type\r\n(following Section.2 of the paper).\r\nWe first consider possible containment predicates for trees.\r\n\r\n\t\treach (h, u) represents a certain value u is present in a tree h.\r\n\t\t\r\nA more interesting predicate class is one that establishes\r\nordering relations between two elements of a data structure,\r\nu and v. Recall that in the heap definition only T constructors\r\ncontain values. However, since T contains two\r\ninductively defined subtrees, there are several cases to consider\r\nwhen establishing an ordering relation among values\r\nfound within a tree h. We use link (h, t, i, j, u, v) to represent\r\nthe ordering relations u is in the i-th component and v is in the j-th\r\ncomponent of constructor T in h.\r\nFor example, if we are interested in cases where the\r\nvalue u appears “before” (according to a specified order) v,\r\nwe could either have that: \r\n\r\n\t\t(i) the value v occurs in the first (left) subtree from a tree node containing u, \r\n\t\tdescribed by the notation link (h, t, 1, 2, u, v), \r\n\r\n\t\t(ii) the value v occurs in the second (right) subtree, described by the notation link (h, t, 1, 3, u, v),\r\n\r\n\t\t(iii) both values are in the tree, but u is found in a subtree that is disjoint from the subtree where v occurs. \r\n\t\tSuppose there exists a node whose first subtree contains u and whose second subtree contains v. \r\n\t\tThis is denoted as link (h, t, 2, 3, u, v). \r\n\t\t\r\nThe symmetric cases are obvious,\r\nand we do not describe them. Notice that in this description\r\nwe have exhausted all possible relations between any two\r\nvalues in a tree. \r\n\r\n_Simplification:_ Given a predicate link (h, t, i, j, u, v), \r\nto improve _readability_ of DOrder, if the\r\ni-th component of constructor T is the only argument of T that is\r\nnot an inductive data type (e.g. the first argument of T in 'a heap \r\ndefinition given above), we simplify the predicate to link (h, t, j, u, v);\r\nif both i-th component and j-th component are of inductive data type\r\n(e.g. the second and third arguments of T in 'a heap), we simplify\r\nthe predicate to link (h, t, ij, u, v). \r\n\r\nAfter synthesizing atomic predicates from datatype definition, \r\nDOrder synthesizes specifications for data structure functions. \r\nConsider the _merge_ function in _heapsort_,\r\n\r\n\tlet rec merge h1 h2 =\r\n\t\tmatch h1, h2 with \r\n\t\t| h1, E -> h1 \r\n\t\t| E, h2 -> h2 \r\n\t\t| (T(rk1, x, a1, b1)), (T(rk2, y, a2, b2)) -> \r\n\t\t\tif x >= y then \r\n\t\t\t\tt x a1 (merge b1 h2) \r\n\t\t\telse \r\n\t\t\t\tt y a2 (merge h1 b2)\r\n\t\r\nBy learning from test outcome, the following specification is synthesized:\r\n\t\r\n\tfunction merge with type h1: {'a heap | some type omitted ... } \r\n\t\t-> h2: {'a heap | sometype omitted ... }\r\n\t\t-> {'a heap |                              \t\t\t\r\n\t\t\t\tforall (u v ). ((not link (V, t, 1, 2, u, v)) or \r\n\t\t\t\tlink (h2, t, 1, 2, u, v) or\r\n\t\t\t\tlink (h2, t, 1, 3, u, v) or\r\n\t\t\t\t(link (h1, t, 1, 3, u, v) or \r\n\t\t\t\tlink (h1, t, 1, 2, u, v)) or\r\n\t\t\t\t((reach (h2, u)) and (reach (h1, v))) or\r\n\t\t\t\t((reach (h2, v)) and (reach (h1, u)))) /\\ ...}\r\n\r\nIn the result type, V represents the result heap. The given specification states that\r\nthe parent-child relation (e.g. link (V, 1, 2, u, v) where u and v are free) between \r\nelements contained in the result heap preserves their parent-child relation \r\n(e.g. link (h2, t, 1, 3, u, v)) in the input heap h1 and h2.\r\n\r\nDOrder also outputs _shape-data_ specifications. For example, for the _heapsort_ function,\r\nthe following specification is synthesized:\r\n\r\n\tfunction heapsort with type ls: 'a list ->\r\n        {'a list | forall (u v ). ((not link (V, cons, 0, 1, u, v)) or  (v <= u)) /\\ ...}\r\n\r\nIn the result type, we see that the output list is correctly sorted, where _cons_\r\nrepresent the Cons data type constructor of list.\r\n\r\nReaders are welcome to validate the experimental results listed in Tab.5 of the paper.\r\n \r\n<a href=\"https://www.cs.purdue.edu/homes/zhu103/pubs/example.pdf\">\r\n\tMore examples on DOrder output (example syntax follows the paper and\r\n\tis directly consistent with link and reach predicates given above).</a> \r\n        \r\n\r\nLearning other specifications beyond the paper\r\n===========\r\n\r\n3. In addition to the above ordering properties, DOrder can also infer and verify inductive numeric specifications for data structures. For example,\r\nwe can infer and verify functional correctness specifications for balanced tree structures (e.g. AVL and Redblack), proving trees can be correctly balanced in\r\nthe data structure implementations. The corresponding inductive data structure benchmarks are included in ./tests/dml/ directory. \r\n\t\r\n\t\tTo try an example, run ./msolve.py -no_hoflag ./tests/dml/bdd.ml or\r\n\t\t \t\t\t\t\t   \r\n\t\t\t\t\t\t\t   ./moslve.py -no_hoflag ./tests/dml/set.ml\r\n\r\n4. DOrder not only handles data structure programs, but also can be used to infer specifications for numeric programs.\r\n\tThe _loop_ (numeric) program benchmarks are included in ./tests/folprograms/ directory.\r\n\r\n        To try an example, run ./msolve.py -no_hoflag ./tests/folprograms/misc/popl07.ml\r\n\r\n\tThe _recursive_ (numeric) program benchmarks are included in ./tests/recursive/ directory. \r\n\r\n\t\tTo try an example, run ./msolve.py -no_hoflag ./tests/recursive/fibonacci01.ml\r\n\r\n\r\n5. DOrder supports _high-order_ functions. The higher-order (numeric) program benchmarks are included \r\nin ./tests/mochi/ ./tests/lists/ and ./tests/popl13/ directories.\r\n\r\n\t\tTo try an example, run ./msolve.py -hoflag ./tests/mochi/ainit.ml\r\n\t\t\r\n6. DOrder can synthesize quantified array invariants.\r\n\tThe _array_ program benchmarks are included in ./tests/array/\r\n\t\r\n\t\tTo try an example, run ./msolve.py -inv -effect ./tests/array/a_quicksort_partition.ml\r\n\r\n\r\nSummary: DOrder Command Line Arguments\r\n==============\r\n\r\n1. To infer shape \r\n\t\t\tspecifications on top of ordering and containment properties for data structure programs, run\r\n\r\n\t\t./msolve.py -no_hoflag -reachability [ML source file]\r\n\r\n\r\n2. To infer specifications for general high-order functional programs, run\r\n       \r\n\t\t./msolve.py -hoflag [ML source file]\r\n\t\t\t\r\n\t\t\r\n3. To turn off the support for higher-order functions (for first-order programs), run\r\n\r\n\t\t./msolve.py -no_hoflag [ML source file]\r\n\t\t\r\n4. To infer quantified array invariants, run\r\n\r\n \t\t./moslve.py -inv -effect [ML source file]\r\n\t\t\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}